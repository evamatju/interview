# mysql
### 慢查询优化
1. 判断索引是否有效(最左匹配原则)
    * like关键字，如果匹配的第一个字符串为%，则不起作用
    * 多列索引，查询条件是否使用了多列索引的第一个字段
    * WHERE子句中，是否进行NULL判断(NULL值判断，不使用索引，而是全表扫描)
2. 数据库结构优化
    * 判断表的列是否过多，对于低频列，进行分割
    * 创建中间表
3. 分解关联查询
4. 只查询必要的列，去除非必要的列，杜绝使用`select *`这种写法
5. 优化limit查询
    * limit查询时，加上order by，可以加速查询
    * 先查出主键ID，在通过id进行limit  
    
**具体操作:** 使用 EXPLAIN 关键字可以模拟优化器执行SQL查询语句  
&emsp;&emsp; **type(关键字段):** 显示查询使用了何种类型。从最好到最差的连接类型为NULL、system、const、eq_ref、ref、range、index和ALL  
参考:[https://blog.csdn.net/jack__frost/article/details/71512404](https://blog.csdn.net/jack__frost/article/details/71512404)

<br/>

### mysql存储引擎对比(InnoDB&MyISAM)
**核心区别:**   
InnoDB支持事务，是具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表;MyISAM不支持事务，崩溃后无法安全恢复。  
**其他:**  
**锁:** InnoDB支持行锁和表锁, (InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁); MyISAM只支持表锁(select时对全表加读锁)。     
**索引:** InnoDB不支持FULLTEXT类型的全文索引(可使用插件支持)，MyISAM支持FULLTEXT类型的全文索引。   
**表主键:** InnoDB如果没有主键，引擎会自动生成也给6字节主键(用户不可见), 数据是索引的一部分(InnoDB中主键所以是和raw data存放在一起的，而非主键索引则是单独存放，然后有个指针指向primary key); MyISAM允许没有索引和主键的表存在，索引保存的是行地址。    
**外键:** InnoDB支持; MyISAM不支持。   
**删表:** InnoDB不会重新建立表，而是一行一行的删除; MyISAM先drop表，然后重建表，更快。(truncate table删除时，两者都是直接删除) -- *留一个问好???*  
**存储空间:** InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
MyISAM可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。 
**移植&备份&恢复:** InnoDB免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump; MyISAM数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。  
**count(\*):** InnoDB中没有保存行数，所以需要全表扫描; MyISAM中保存有当前行的总数,可直接返回。 如果带有where语句时，都需要通过索引扫描(使用非主键索引，可以读取数据的IO)。  
**AUTO_INCREMENT:** InnoDB中必须包含只有该字段的索引;也可以在组合索引中，但必须是组合索引的第一列。MyISAM的自动增长列必须是索引，但可以是组合索引，也不必一定是第一列。  
**选择:**    
采用InnoDB引擎:

        * R/W比较小，频繁更新大字段
        * 表数据量超过1000万，并发高
        * 安全性和可用性要求高
采用InnoDB引擎:

        * R/W比较小，频繁更新大字段 
        * 表数据量超过1000万，并发高
        * 安全性和可用性要求高

##### 为什么MyISAM会比InnoDB的查询速度快？
1. InnoDB要缓存数据块，MyISAM只缓存索引块，数据换进换出MyISAM更少  
2. InnoDB寻址，先要映射到块，再映射到行；MyISAM记录的直接是文件的OFFSET，定位比InnoDB要快  
3. InnoDB需要维护MVCC一致性(即使没有使用到)

<br/>

### 索引
##### 聚簇索引&非聚簇索引(物理角度)
**聚簇索引:** 表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。在一张表上最多只能创建一个聚集索引(因为真实数据的物理顺序只能有一种)。   
**非聚簇索引:** 又称辅助索引，表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针(或者聚簇索引值)，其行数量与数据表行数据量一致(所以，一般都需要两次查询)。   
![innodb&myisam索引图](https://github.com/shaoxuefeng/interview/blob/master/2020-04/相关图片/innodb%26myisam索引图.webp "InnoDB&MyISAM索引图") 
如上图所示:  
&emsp;&emsp; 若使用`where id=14`这样的条件查找主键，则主键索引(聚簇索引)即可查找到对应的叶节点，之后获得行数据。  
&emsp;&emsp; 若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name,到达其叶子节点获取对应的主键(页面节点存储的是索引值+主键索引值)。第二步使用主键在主索引B+树再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。  

<br/>

##### 索引分类(使用角度/逻辑角度)
1. **普通索引**, 最基本的索引，它没有任何限制。 `CREATE INDEX|KEY` 
2. **唯一索引**, 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 `CREATE UNIQUE INDEX|KEY`
3. **主键索引**, 特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引 `PRIMARY KEY`
4. **组合索引**, 多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。(最左匹配原则)
5. **全文索引**, 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。目前只有char、varchar，text 列上可以创建全文索引。 `CREATE FULLTEXT INDEX`
    > 查询匹配: WHERE MATCH(colname) AGAINST (`val_str`)

<br/>

##### B+树索引
B+树索引本质上就是B+树在数据库中的实现，与纯粹的B+树数据结构还是有点区别:
|      | B+树  |B+树索引|
| :--- | :---  | :---- |
| 存储位置| 内存| 磁盘 |
| [扇出率](https://blog.csdn.net/imzoer/article/details/8528973) | 低 | 高 |
| 并发控制 | 不考虑 | 关注点 |
| 分裂方向 | 不考虑 | 向左、向右 |
1. 磁盘读写代价低
> 分支节点没有存储数据，因此其内部节点相对B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
2. 查询效率文档，均为 O(log n)
3. B+树便于执行扫库操作和批量查询 
> B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。同时，叶子节点的双向链表，更适合适合范围查找。

<br/>

##### Hash索引
**原理:** 基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code)。  
![Hash索引原理](https://github.com/shaoxuefeng/interview/blob/master/2020-04/相关图片/hash索引原理图.jpg "Hash索引原理")  
针对上图进行解释:  

    > keys：代表创建索引的列值；  
    > buckets： 就是计算出来的hash值和对应的数据的物理位置组成的hash表；  
    > entries：就是代表具体的数据行；  
**优点:** 查询速度快，索引的检索可以一次定位  
**不足:**  
1. Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
2. Hash 索引无法被用来避免数据的排序操作。
3. Hash 索引不能利用部分索引键查询, 必须全部匹配。
4. Hash 索引在任何时候都不能避免表扫描。 
5. Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 
 
**总结:** 如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引   
参考:[http://blog.itpub.net/29654823/viewspace-2150134/](http://blog.itpub.net/29654823/viewspace-2150134/)

<br/>

### 事务 -- 指的是一系列操作
##### 事务的特性 ACID
**A(Atomicity)原子性:** 事务是数据库的逻辑工作单位，不可分割，事务中包含的各操作要么都做，要么都不做  
> 对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）

**C(Consistency)一致性:** 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。  
> 保证了隔离性+原子性，则可以保证一致性

**I(Isolation)隔离性:** 一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。  
> 加锁/序列化

**D(Durability)持久性:** 指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的，不能回滚。接下来的其它操作或故障不应该对其执行结果有任何影响。  
> 读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性）

<br/>

##### 事务并行的影响
1. 更新丢失 -- 两个事务同时写了某一行
2. 脏读 -- 一个事务读取到了另外一个事务还未提交的记录
3. 不可重复度 -- 一个事务的两次相同读取，返回的结果不一样
    * 虚读 -- 事务A读取某行数据后，事务B对其进行了修改，导致事务A再次读取时，结果不一致
    * 幻读 -- 事务A进行批量读取时，事务B进行了insert或者delete操作，导致两次读取，结果不一致

<br/>

##### 隔离等级(由低到高)
**读未提交(Read Uncommitted):** 只处理更新丢失。  
    * 事务对当前被读取的数据不加锁；
    * 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级共享锁，直到事务结束才释放。  
**读提交(Read Committed):** 处理更新丢失和脏读。  
    * 事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
    * 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
**可重复读(Repeatable Read):** 处理更新丢失、脏读和不可重复读(mysql默认隔离等级)  
    * 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；  
    * 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
**序列化(Serializable):**  提供严格的事务隔离,杜绝并发执行
    * 事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；
    * 事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。
|      |  脏读  |不可重复读| 幻读 |
| :--- | :---- | :----    | :--- |
| 读未提交 | √  |   √  |  √  | 
| 读提交 | × |   √  | √  |
| 可重复读 | × | × | √  |
| 序列化 |  × |  × |  × | 

备注: √表示会发生， ×表示不会发生
参考: [https://blog.csdn.net/jyxmust/article/details/77835848](https://blog.csdn.net/jyxmust/article/details/77835848)

<br/>

##### MVCC(多版本并发控制 Multiversion Concurrency Control)
**InnoDB的行中的额外信息:**  
DATA_TRX_ID: 最新更新这条行记录的transaction id，每处理一个事务，其值自动+1  
DATA_ROLL_PTR: 指向当前记录项的回滚段(rollback segment)的undo log记录，通过这个指针找到之前版本的数据。  
DELETE BIT: 用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除。  
DB_ROW_ID: 如果建表时没有主键，InnoDB会自动生成一个自增主键。   
**增删改查实现逻辑:**  
**1. SELECT**  
&emsp;&emsp; InnoDB只查找版本早于（包含等于）当前事务版本的数据行。可以确保事务读取的行，要么是事务开始前就已存在，或者事务自身插入或修改的记录。  
&emsp;&emsp; 行的删除版本要么未定义，要么大于当前事务版本号。可以确保事务读取的行，在事务开始之前未删除。  
**2. INSERT**  
&emsp;&emsp; InnoDB为新插入的每一行保存当前系统版本号作为行版本号。    
**3. DELETE**  
&emsp;&emsp; 将删除的行保存当前版本号为删除标识。   
**4. UPDATE**  
&emsp;&emsp; 变为insert和delete操作的组合，insert的行保存当前版本号为行版本号，delete则保存当前版本号到原来的行作为删除标识。

**注意:** 由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。  

<br/>

#### 数据库锁
##### 概念锁(乐观锁&悲观锁)
**乐观锁:** 也叫乐观并发控制，它总是乐观的认为用户在并发事务处理时不会影响彼此的数据。  
**悲观锁:** 悲观锁会悲观的认为每次去拿的数据都会被别人修改。所以每次在拿数据的时候都会上锁，从而屏蔽可能违反数据完整性的操作。间隙锁、临键锁都属于悲观锁。  

##### 作用范围区分(表锁&行锁)
表级锁有：意向共享锁、意向排他锁、自增锁等。  
行级锁有：共享锁、排他锁、记录锁  
**备注:** 只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁 

##### 共享锁&排他锁  
**共享锁/读锁:** 其他事务可读，但是不能写  `lock in share mode`  
**排他锁/写锁:** 其他事务不能读，也不能写  `select *** for update`

更多其他锁:[参考这里](https://www.jianshu.com/p/af2f5fed3b6d) 

<br/>

### 存储过程&触发器
**存储过程:** 将常用的或很复杂的工作，预先用SQL语句写好并用一个指定的名称存储起来, 那么以后要叫数据库提供与已定义好的存储过程的功能相同的服务时,只需调用execute,即可自动完成命令。   
    `CREATE PROCEDURE sp_name ([proc_parameter[,...]]) BEGIN *** END`  
&emsp;&emsp; **优点:**  
1. 存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，可以提高执行速度。
2. 当对数据库进行复杂操作时(如对多个表进行Update,Insert,Query,Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。 
3. 存储过程可以重复使用,可减少数据库开发人员的工作量 。
4. 安全性高,可设定只有某此用户才具有对指定存储过程的使用权。

**触发器:** 是个特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由个事件来触发。触发器经常用于加强数据的完整性约束和业务规则等。   
    `CREATE TRIGGER name BEFORE/AFTER ** ON ** BEGIN ** END`  
&emsp;&emsp; **优点:**   
1. 触发器可通过数据库中的相关表实现级联更改；

**对比:** 触发器可以看作一种特殊的存储过程;但二者执行方式不同，存储过程由手工调用，还可以传入参数， 触发器在被监测表发送变化是，自动执行。  

<br/>

### 其他问题
##### 1. 数据库三范式
&emsp;&emsp;&emsp;&emsp; 1NF 列不可分割  
&emsp;&emsp;&emsp;&emsp; 2NF 不可部分依赖主键，必须全部依赖  
&emsp;&emsp;&emsp;&emsp; 3NF 不可传递依赖

##### 2. Join实现的原理
**三种方式:**  
1. 普通循环嵌套查询
2. 索引循环嵌套查询
3. 缓存循环嵌套查询  

**join连接优化:**
1. 以小表为驱动表
2. 非驱动表，创建索引，加速查询

##### 3. mysql主从同步 -- binlog
mysql 主从同步，通过日志文件实现; 为了保证数据的准确性，可以写入二进制日志文件前，可取消写入缓存的操作。  
**具体实现:** -- 通过三个线程  
1.  一个master服务的线程，将master上的二进制文件，传送到slaver上;
2.  slave上，一个IO进程，接受master发送来的数据，写入到中继日志中;
3.  slave上，一个sql进程，将中继日志中的信息，写入到slave上的机器中

**同步方式:** Row&Statement   
**1). Statement Based Replication(SBR):** 基于SQL语句的复制  
&emsp;&emsp; 每一条会修改数据的sql都会记录到master的binlog中，slave在复制的时候sql进程会解析成和原来master端执行多相同的sql再执行。    
**优点:** 日志文件小，方便后续审计。  
**缺点:**   
&emsp;&emsp; 1.部分update语句无法复制; 尤其是包含不确定操作的时候。  
&emsp;&emsp; 2.部分函数无法执行，比如USER()、UUID()等。  
&emsp;&emsp; 3.从库执行的INSERT和UPDATE会造成很多行级锁。   
**2). Row Based Replication(RBR):** 基于行复制  
&emsp;&emsp;  日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改，只记录要修改的数据，只有value，不会有sql多表关联的情况。   
**优点:**   
&emsp;&emsp; 1.任何情况都可以被复制，这对复制来说是最安全可靠的。  
&emsp;&emsp; 2.INSERT、UPDATE等操作时，行锁更少。  
**缺点:** 生成的binlog日志量特别大   
**3). Mixed-based Based Replication(MBR):** 混合模式复制  
&emsp;&emsp;  在 Mixed 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种。



