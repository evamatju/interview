# mysql
### 慢查询优化
1. 判断索引是否有效(最左匹配原则)
    * like关键字，如果匹配的第一个字符串为%，则不起作用
    * 多列索引，查询条件是否使用了多列索引的第一个字段
    * WHERE子句中，是否进行NULL判断(NULL值判断，不使用索引，而是全表扫描)
2. 数据库结构优化
    * 判断表的列是否过多，对于低频列，进行分割
    * 创建中间表
3. 分解关联查询
4. 只查询必要的列，去除非必要的列，杜绝使用`select *`这种写法
5. 优化limit查询
    * limit查询时，加上order by，可以加速查询
    * 先查出主键ID，在通过id进行limit  
    
**具体操作:** 使用 EXPLAIN 关键字可以模拟优化器执行SQL查询语句  
&emsp;&emsp; **type(关键字段):** 显示查询使用了何种类型。从最好到最差的连接类型为NULL、system、const、eq_ref、ref、range、index和ALL  
参考:[https://blog.csdn.net/jack__frost/article/details/71512404](https://blog.csdn.net/jack__frost/article/details/71512404)

<br/>

### mysql存储引擎对比(InnoDB&MyISAM)
**核心区别:**   
InnoDB支持事务，是具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表;MyISAM不支持事务，崩溃后无法安全恢复。  
**其他:**  
**锁:** InnoDB支持行锁和表锁, (InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁); MyISAM只支持表锁(select时对全表加读锁)。     
**索引:** InnoDB不支持FULLTEXT类型的全文索引(可使用插件支持)，MyISAM支持FULLTEXT类型的全文索引。   
**表主键:** InnoDB如果没有主键，引擎会自动生成也给6字节主键(用户不可见), 数据是索引的一部分(InnoDB中主键所以是和raw data存放在一起的，而非主键索引则是单独存放，然后有个指针指向primary key); MyISAM允许没有索引和主键的表存在，索引保存的是行地址。    
**外键:** InnoDB支持; MyISAM不支持。   
**删表:** InnoDB不会重新建立表，而是一行一行的删除; MyISAM先drop表，然后重建表，更快。(truncate table删除时，两者都是直接删除) -- *留一个问好???*  
**存储空间:** InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
MyISAM可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。 
**移植&备份&恢复:** InnoDB免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump; MyISAM数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。  
**count(\*):** InnoDB中没有保存行数，所以需要全表扫描; MyISAM中保存有当前行的总数,可直接返回。 如果带有where语句时，都需要通过索引扫描(使用非主键索引，可以读取数据的IO)。  
**AUTO_INCREMENT:** InnoDB中必须包含只有该字段的索引;也可以在组合索引中，但必须是组合索引的第一列。MyISAM的自动增长列必须是索引，但可以是组合索引，也不必一定是第一列。  
**选择:**    
采用InnoDB引擎:

        * R/W比较小，频繁更新大字段
        * 表数据量超过1000万，并发高
        * 安全性和可用性要求高
采用InnoDB引擎:

        * R/W比较小，频繁更新大字段 
        * 表数据量超过1000万，并发高
        * 安全性和可用性要求高

##### 为什么MyISAM会比InnoDB的查询速度快？
1. InnoDB要缓存数据块，MyISAM只缓存索引块，数据换进换出MyISAM更少  
2. InnoDB寻址，先要映射到块，再映射到行；MyISAM记录的直接是文件的OFFSET，定位比InnoDB要快  
3. InnoDB需要维护MVCC一致性(即使没有使用到)

<br/>

### 索引
##### 聚簇索引&非聚簇索引(物理角度)
**聚簇索引:** 表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。在一张表上最多只能创建一个聚集索引(因为真实数据的物理顺序只能有一种)。   
**非聚簇索引:** 又称辅助索引，表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针(或者聚簇索引值)，其行数量与数据表行数据量一致(所以，一般都需要两次查询)。   
![innodb&myisam索引图](https://github.com/shaoxuefeng/interview/blob/master/2020-04/相关图片/innodb%26myisam索引图.webp "InnoDB&MyISAM索引图") 
如上图所示:  
&emsp;&emsp; 若使用`where id=14`这样的条件查找主键，则主键索引(聚簇索引)即可查找到对应的叶节点，之后获得行数据。  
&emsp;&emsp; 若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name,到达其叶子节点获取对应的主键(页面节点存储的是索引值+主键索引值)。第二步使用主键在主索引B+树再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。  

##### 索引分类(使用角度/逻辑角度)
1. **普通索引**, 最基本的索引，它没有任何限制。 `CREATE INDEX|KEY` 
2. **唯一索引**, 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 `CREATE UNIQUE INDEX|KEY`
3. **主键索引**, 特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引 `PRIMARY KEY`
4. **组合索引**, 多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。(最左匹配原则)
5. **全文索引**, 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。目前只有char、varchar，text 列上可以创建全文索引。 `CREATE FULLTEXT INDEX`
    > 查询匹配: WHERE MATCH(colname) AGAINST (`val_str`)

##### B+树索引
B+树索引本质上就是B+树在数据库中的实现，与纯粹的B+树数据结构还是有点区别:
|      | B+树  |B+树索引|
| :--- | :---  | :---- |
| 存储位置| 内存| 磁盘 |
| [扇出率](https://blog.csdn.net/imzoer/article/details/8528973) | 低 | 高 |
| 并发控制 | 不考虑 | 关注点 |
| 分裂方向 | 不考虑 | 向左、向右 |
1. 磁盘读写代价低
> 分支节点没有存储数据，因此其内部节点相对B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
2. 查询效率文档，均为 O(log n)
3. B+树便于执行扫库操作和批量查询 
> B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。同时，叶子节点的双向链表，更适合适合范围查找。

##### Hash索引
**原理:** 基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code)。  
![Hash索引原理](https://github.com/shaoxuefeng/interview/blob/master/2020-04/相关图片/hash索引原理图.jpg "Hash索引原理")  
针对上图进行解释:  

    > keys：代表创建索引的列值；  
    > buckets： 就是计算出来的hash值和对应的数据的物理位置组成的hash表；  
    > entries：就是代表具体的数据行；  
**优点:** 查询速度快，索引的检索可以一次定位  
**不足:**  
1. Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
2. Hash 索引无法被用来避免数据的排序操作。
3. Hash 索引不能利用部分索引键查询, 必须全部匹配。
4. Hash 索引在任何时候都不能避免表扫描。 
5. Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 
 
**总结:** 如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引   
参考:[http://blog.itpub.net/29654823/viewspace-2150134/](http://blog.itpub.net/29654823/viewspace-2150134/)


