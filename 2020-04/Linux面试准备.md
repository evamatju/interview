# Linux

### Linux 常用命令
查看cpu -- top:(也可以查看内存)    
* 前五行是系统情况整体的统计信息区：任务队列信息、进程信息、cpu占比、swap大小，一下是各个进程详情。  

查看内存 -- free:    
* 显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。

查看进程 -- ps   
查看断开 -- lsof/netstat   

注: swap分区为交换分区，即当内存空间不够时，取出一部分暂时不用的数据，放在交换分区中。  
##### 其他命令
tracert: 通过icmp报文，查询到目标地址的路由  
ping: 通过发送icmp报文，确定目标地址是否可达  
telent: tcp连通测试工具  

#### Linux权限位
第1位: 代表文件类  普通文件为"\-", 软连接"l"， 目录为"d",  字符设备为"c"，块文件为"b"  
第2\~4位: 代表所有者的权限      
第5\~7位: 代表所属组的权限       
第8\~10位: 代表其他人的权限      

#### Linux硬连接&软连接
A是B的**硬连接**, 则A和B指向的是相同的inode节点，只是有不同的文件名。A和B是相等的，删除其中一个对另外一个没有任何影响。每增加一个文件名，inode节点上的链接数增加1。    
A是B的**软链接**，则目录A的inode节点和目录B的inode节点不一样。文件名A指向的是存放“文件B路径的区域”，文件B指向的是真正存放文件的地域。  

<br/>

#### Linux僵尸进程&孤儿进程  
##### 僵尸进程
&emsp;&emsp; 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。通过ps命令查看其带有defunct的标志。      
&emsp;&emsp;   僵尸状态的目的是维护子进程的信息，包括子进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)，以便父进程在以后某个时间获取。   

**解决办法:**  
1. 父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。执行wait（）或waitpid（）系统调用，则子进程在终止后会立即把它在进程表中的数据返回给父进程，此时系统会立即删除该进入点。在这种情形下就不会产生defunct进程。  
2. 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler。在子进程结束后，父进程会收到该信号，可以在handler中调用wait回收。  
3. 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCLD,SIG_IGN）或signal（SIGCHLD, SIG_IGN）通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号。  
4. fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。  

##### 孤儿进程
一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。  

<br/>

#### Linux 锁
##### 1. 互斥锁(mutex)
对于读者和写者来说。只要有一方获取了锁，另一方则不能继续获取，进而执行临界区代码。  
> 谁加锁谁释放，其他使用者没有释放权限。    
> 互斥锁无法获取锁时将阻塞睡眠，需要系统来唤醒。 

##### 2. 读写锁(rwlock)
读模式锁定时可以共享,以写模式锁住时意味着独占。（适用于读多写少的情况）  

##### 3. 自旋锁(spinlock) -- 循环忙等  
使用者在想要获得临界区执行权限时，如果临界区已经被加锁，那么自旋锁并不会阻塞睡眠，等待系统来主动唤醒，而是原地忙轮询资源是否被释放加锁。 一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。    
**适用于:** 锁使用者保持锁时间比较短的情况。  
**优点:**  避免了各种上下文切换，开销非常小  
**缺点:**  单核cpu下不起作用; 被自旋锁保护的临界区代码执行时不能进行挂起状态, 会造成死锁。 

<br/>

#### Linux进程地址(虚拟地址)空间
Linux系统为每个进程都开辟了4G的内存空间。（为什么是4G，因为32为指针，对应的寻址范围是4G）  
4G地址空间: 0-3G为用户空间，3-4G为内核空间。    
由低到高，分别存放程序段(二进制代码)、初始化过的数据（DATA段）、未初始化过的数据（BSS段）、堆区、内存映射段（mmap）、栈区、内核空间   
![虚拟内存地址空间](https://github.com/shaoxuefeng/interview/blob/master/2020-04/相关图片/Linux进程虚拟内存地址.jpg "虚拟内存地址空间")  
参考:[https://www.cnblogs.com/beixiaobei/p/10507462.html](https://www.cnblogs.com/beixiaobei/p/10507462.html)  

##### 逻辑地址 -> 线性/虚拟地址 -> 物理地址
&emsp;&emsp; **段管理: 逻辑地址到虚拟地址**    
一个逻辑地址由两部份组成，段标识符+段内偏移量。（段标识符和偏移量各占16位，其中段标识符的前13位标识索引，14位标识指示器，使用哪个描述符表） 
 > 全局描述符表(GDT)：全局描述符表GDT(Global Descriptor Table)，包含着系统中所有任务都共用的那些段的描述符。    
 > 
> 局部描述符表(LDT)：局部描述符表LDT(local Descriptor Table)，包含了与一个给定任务有关的描述符，每个任务各自有一个的LDT。 有了LDT，就可以使给定任务的代码、数据与别的任务相隔离。
    
通过索引值+描述符表，得到基地址，然后加上偏移量，得到的是线性地址。   

&emsp;&emsp; **页管理: 线性地址到物理地址**    
每一个32位的线性地址被划分为三部份，面目录索引(10位)：页表索引(10位)：偏移(12位)    
通过 页目录+页表+偏移，得到物理地址。  
参考:[https://www.cnblogs.com/alantu2018/p/9002441.html](https://www.cnblogs.com/alantu2018/p/9002441.html)  



